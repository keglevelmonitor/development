# keglevel app
#
# main.py
import sys
import os
import tkinter as tk
from tkinter import messagebox
import uuid 
import subprocess 
import re 
import platform 
import shutil 
import signal 
from pathlib import Path 

# --- AUTOGENERATED FILE MANAGEMENT LOGIC ---
AUTOSTART_DIR_REL = ".config/autostart"
DESKTOP_FILE_NAME = "keglevel.desktop" 
SOURCE_DESKTOP_PATH = Path.home() / ".local" / "share" / "applications" / DESKTOP_FILE_NAME

def get_autostart_path():
    """Returns the full path to the user's autostart directory."""
    return Path.home() / AUTOSTART_DIR_REL

def manage_autostart_file(action):
    """
    Copies the INSTALLED .desktop file to the autostart folder.
    action: 'add' or 'remove'
    """
    autostart_dir = get_autostart_path()
    desktop_file_path = autostart_dir / DESKTOP_FILE_NAME
    source_path = SOURCE_DESKTOP_PATH
    
    if action == 'add':
        if not source_path.exists():
            print(f"Error: Installed source shortcut not found at {source_path}")
            print("Please run install.sh to ensure the app is installed correctly.")
            # Use a safe fallback for the parent if root isn't created yet
            try:
                messagebox.showerror("Autostart Error", f"Cannot enable autostart.\nSource file missing:\n{source_path}\n\nPlease run ./install.sh again.")
            except:
                pass
            return False

        try:
            autostart_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            print(f"Error creating autostart directory {autostart_dir}: {e}")
            return False

        try:
            shutil.copy2(source_path, desktop_file_path)
            os.chmod(desktop_file_path, 0o755) 
            print(f"Autostart file copied successfully from {source_path} to {desktop_file_path}")
            return True
        except Exception as e:
            print(f"Error copying/setting permissions for autostart file: {e}")
            return False

    elif action == 'remove':
        try:
            if desktop_file_path.exists():
                desktop_file_path.unlink()
                print(f"Autostart file removed successfully from {desktop_file_path}")
                return True
            else:
                print("Autostart file does not exist, no action needed.")
                return True
        except Exception as e:
            print(f"Error removing autostart file: {e}")
            return False
    
    return False

# --- SIGNAL HANDLING FOR TERMINAL CLOSURE ---
def handle_exit_signal(signum, frame):
    """
    Robust signal handler that prioritizes hardware cleanup.
    """
    try:
        # Access the global sensor_ctrl if it exists
        if 'sensor_ctrl' in globals() and sensor_ctrl:
            sensor_ctrl.cleanup_gpio()
    except Exception:
        pass 

    try:
        # Check if SIGHUP exists (Linux/Unix only)
        is_sighup = hasattr(signal, 'SIGHUP') and signum == signal.SIGHUP
        signal_name = "SIGHUP" if is_sighup else "SIGTERM"
        print(f"\n[SHUTDOWN] Received {signal_name}. Hardware cleanup complete.")
    except (IOError, OSError):
        pass 

    os._exit(0)

# Register the signals safely
if hasattr(signal, 'SIGHUP'):
    signal.signal(signal.SIGHUP, handle_exit_signal)
    
signal.signal(signal.SIGTERM, handle_exit_signal)

# --- GLOBAL VARIABLES FOR SIGNAL HANDLER ACCESS ---
sensor_ctrl = None

# --- MAIN EXECUTION FUNCTION ---
def main():
    global sensor_ctrl
    
    LAUNCH_BEVERAGE_LIBRARY = False
    if len(sys.argv) > 1:
        if sys.argv[1] == "--open-beverage-library":
            LAUNCH_BEVERAGE_LIBRARY = True

    # Import modules inside main to avoid circular deps or early execution
    from settings_manager import SettingsManager
    from sensor_logic import SensorLogic, FLOW_SENSOR_PINS
    from ui_manager import UIManager
    from notification_service import NotificationService
    from temperature_logic import TemperatureLogic
    from sensor_logic import is_raspberry_pi
    
    # Import the new wizard
    from setup_wizard import SetupWizard

    # Setup paths
    if os.path.exists('src'):
        script_path = os.path.abspath('src')
        data_path = os.path.join(os.path.dirname(script_path), "..", "keglevel-data") 
        if not os.path.exists(data_path):
             data_path = os.path.abspath('.') 
    else:
        script_path = os.path.dirname(os.path.abspath(__file__))
        data_path = os.path.expanduser("~/keglevel-data")

    num_configured_sensors = len(FLOW_SENSOR_PINS)
    app_version_string = "V1.0"

    # --- Sub-Process Startup ---
    if LAUNCH_BEVERAGE_LIBRARY: 
        try:
            settings_mgr = SettingsManager(num_sensors_expected=num_configured_sensors)
            temp_root = tk.Tk()
            temp_root.withdraw() 
            temp_ui = UIManager(
                temp_root, settings_mgr, None, None, None, num_configured_sensors, app_version_string
            )
            temp_ui._open_beverage_library_popup() 
            temp_root.mainloop()
        except Exception as e:
            print(f"Error launching sub-process UI: {e}")
        finally:
            sys.exit(0)
    
    # --- Normal Startup ---
    # Initialize Settings Manager First
    settings_mgr = SettingsManager(num_configured_sensors)
    
    # --- PHASE 2: WIZARD CHECK ---
    # Check if setup is complete. If not, launch Wizard.
    if not settings_mgr.get_setup_complete():
        print("Main: Setup not complete. Launching Wizard...")
        try:
            wizard = SetupWizard(settings_mgr)
            success = wizard.run() # Blocks until wizard closes
            
            if not success:
                print("Main: Setup cancelled by user. Exiting.")
                sys.exit(0)
            
            # If successful, the settings are saved, proceed to main app launch
            print("Main: Wizard complete. Launching UI.")
            
        except Exception as e:
            print(f"Main: Error during setup wizard: {e}")
            sys.exit(1)
    # -----------------------------
    
    is_pi = is_raspberry_pi()
    print(f"Running on RPi hardware: {is_pi}")
    if not is_pi:
        print("WARNING: Not running on Raspberry Pi. GPIO features will be emulated/disabled.")

    root = tk.Tk()
    root.title("Keg Level Monitor")
    root.geometry("800x600")

    notification_svc = NotificationService(settings_manager=settings_mgr, ui_manager=None)
    temp_logic_svc = TemperatureLogic(ui_callbacks={}, settings_manager=settings_mgr)
    
    sensor_ctrl = SensorLogic(
        num_sensors_from_config=num_configured_sensors,
        ui_callbacks={}, 
        settings_manager=settings_mgr,
        notification_service=notification_svc
    )

    ui = UIManager(
        root,
        settings_mgr,
        sensor_ctrl,
        notification_svc,
        temp_logic_svc,
        num_configured_sensors,
        app_version_string
    )

    # Link services
    notification_svc.ui_manager = ui
    if ui.notification_service and hasattr(ui, 'update_notification_status_display'):
        ui.notification_service.ui_manager_status_update_cb = ui.update_notification_status_display
    if ui.temp_logic and hasattr(ui, 'update_temperature_display'):
        ui.temp_logic.ui_callbacks["update_temp_display_cb"] = ui.update_temperature_display
        
# --- SCHEDULE EULA POPUP (Fallback) ---
    # Note: If Wizard runs successfully, eula_agreed will be True, so this won't show.
    system_settings = settings_mgr.get_system_settings()
    eula_agreed = system_settings.get("eula_agreed", False)
    
    # We now strictly respect eula_agreed. 'show_eula_on_launch' is deprecated but checked for safety.
    show_on_launch = system_settings.get("show_eula_on_launch", False)
    
    if not eula_agreed or show_on_launch:
        print("Main: EULA not agreed. Scheduling EULA popup.")
        # Delaying by 200ms allows the main loop to start and the window to be mapped
        # CALLS THE NEW RENAMED FUNCTION: _open_eula_popup
        root.after(200, lambda: ui._open_eula_popup(is_launch=True))
        
    # --- CHECK FOR UPDATES ON LAUNCH ---
    if settings_mgr.get_check_updates_on_launch():
        # Schedule it slightly later (e.g., 2 seconds) so the UI loads first
        print("Main: Scheduling update check on launch...")
        root.after(2000, lambda: ui._check_for_updates(is_launch_check=True))

    # Start Services
    if notification_svc: notification_svc.start_scheduler()
    if temp_logic_svc: temp_logic_svc.start_monitoring()
    if sensor_ctrl: sensor_ctrl.start_monitoring()
    
    if settings_mgr.get_launch_workflow_on_start():
        # Also schedule workflow popup to prevent blocking
        root.after(500, ui._open_workflow_popup)
    
    # Start Main Loop
    try:
        ui.run() # This wraps root.mainloop()
    except KeyboardInterrupt:
        print("\n[SHUTDOWN] KeyboardInterrupt detected (Ctrl+C).")
    except SystemExit:
        pass 
    except Exception as e:
        print(f"\n[CRITICAL ERROR] Application crashed: {e}")
    finally:
        print("[SHUTDOWN] Performing standard exit cleanup...")
        if sensor_ctrl:
            sensor_ctrl.cleanup_gpio()
        print("[SHUTDOWN] Cleanup complete.")

    print("Main: Application has exited mainloop.")
    
if __name__ == "__main__":
    main()
