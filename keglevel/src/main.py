# keglevel app
#
# main.py
import sys
import os
import tkinter as tk
from tkinter import messagebox
import uuid 
import subprocess 
import re 
import platform 
import shutil 
import signal # <--- NEW IMPORT
from pathlib import Path 

# --- NEW AUTOGENERATED FILE MANAGEMENT LOGIC ---
AUTOSTART_DIR_REL = ".config/autostart"
# FIX: Match the lowercase filename used by the installer
DESKTOP_FILE_NAME = "keglevel.desktop" 

# --- CRITICAL FIX: Source file is now the INSTALLED system menu shortcut ---
# This points to ~/.local/share/applications/keglevel.desktop
SOURCE_DESKTOP_PATH = Path.home() / ".local" / "share" / "applications" / DESKTOP_FILE_NAME
# --- END CRITICAL FIX ---


def get_autostart_path():
    """Returns the full path to the user's autostart directory."""
    return Path.home() / AUTOSTART_DIR_REL

def manage_autostart_file(action):
    """
    Copies the INSTALLED .desktop file to the autostart folder.
    action: 'add' or 'remove'
    """
    autostart_dir = get_autostart_path()
    desktop_file_path = autostart_dir / DESKTOP_FILE_NAME
    source_path = SOURCE_DESKTOP_PATH
    
    if action == 'add':
        if not source_path.exists():
            # FIX: Error message reflects the new expected system location
            print(f"Error: Installed source shortcut not found at {source_path}")
            print("Please run install.sh to ensure the app is installed correctly.")
            messagebox.showerror("Autostart Error", f"Cannot enable autostart.\nSource file missing:\n{source_path}\n\nPlease run ./install.sh again.", parent=tk._default_root)
            return False

        try:
            autostart_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            print(f"Error creating autostart directory {autostart_dir}: {e}")
            return False

        try:
            shutil.copy2(source_path, desktop_file_path)
            os.chmod(desktop_file_path, 0o755) 
            
            print(f"Autostart file copied successfully from {source_path} to {desktop_file_path}")
            return True
        except Exception as e:
            print(f"Error copying/setting permissions for autostart file: {e}")
            return False

    elif action == 'remove':
        try:
            if desktop_file_path.exists():
                desktop_file_path.unlink()
                print(f"Autostart file removed successfully from {desktop_file_path}")
                return True
            else:
                print("Autostart file does not exist, no action needed.")
                return True
        except Exception as e:
            print(f"Error removing autostart file: {e}")
            return False
    
    return False

# --- END NEW AUTOGENERATED FILE MANAGEMENT LOGIC ---


LAUNCH_BEVERAGE_LIBRARY = False

if len(sys.argv) > 1:
    if sys.argv[1] == "--open-beverage-library":
        LAUNCH_BEVERAGE_LIBRARY = True

# --- CRITICAL FIX: SIGNAL HANDLING FOR TERMINAL CLOSURE ---
def handle_exit_signal(signum, frame):
    """
    Robust signal handler that prioritizes hardware cleanup over logging.
    Handles SIGHUP (Terminal Close) and SIGTERM (Logout/System Shutdown).
    """
    # 1. EXECUTE CLEANUP FIRST (Before attempting to print)
    # We rely on the global 'sensor_ctrl' initialized in __main__
    try:
        if 'sensor_ctrl' in globals() and sensor_ctrl:
            sensor_ctrl.cleanup_gpio()
    except Exception:
        pass # Hardware safety failed, nothing else we can do

    # 2. Attempt to log (This might fail if terminal is closed, so we wrap it)
    try:
        signal_name = "SIGHUP" if signum == signal.SIGHUP else "SIGTERM"
        print(f"\n[SHUTDOWN] Received {signal_name}. Hardware cleanup complete.")
    except (IOError, OSError):
        pass # Stdout is likely dead (terminal closed), ignore the error

    # 3. FORCE EXIT
    # We use os._exit() to kill the process immediately. 
    # sys.exit() throws an exception that Tkinter might catch/block.
    os._exit(0)

# Register the signals
signal.signal(signal.SIGHUP, handle_exit_signal)
signal.signal(signal.SIGTERM, handle_exit_signal)
# ----------------------------------------------------------

if __name__ == "__main__":
    # Import other modules here
    from settings_manager import SettingsManager
    # MODIFIED: Import FLOW_SENSOR_PINS instead of ULTRASONIC_SENSORS_GPIO
    from sensor_logic import SensorLogic, FLOW_SENSOR_PINS
    from ui_manager import UIManager
    from notification_service import NotificationService
    from temperature_logic import TemperatureLogic
    
    # --- REFACTOR: REMOVED ALL licensing_popup AND KeyManager IMPORTS ---
    
    # MODIFIED: Use the new flow sensor pins count
    num_configured_sensors = len(FLOW_SENSOR_PINS)
    
    # --- REFACTOR: Hardcoded revision string, as in main_fv.py ---
    app_version_string = "V1.0"

    # -----------------------------------------------------------
    # Sub-Process Startup (Beverage Library or Workflow)
    # -----------------------------------------------------------
    if LAUNCH_BEVERAGE_LIBRARY: 
        try:
            # --- CRITICAL FIX: Base directory is now resolved by SettingsManager ---
            settings_mgr = SettingsManager(num_sensors_expected=num_configured_sensors)
            # --- END FIX ---
            
            temp_root = tk.Tk()
            temp_root.withdraw() 
            temp_ui = UIManager(
                temp_root, settings_mgr, None, None, None, num_configured_sensors, app_version_string
            )
            temp_ui._open_beverage_library_popup() 
            temp_root.mainloop()

        except Exception as e:
            print(f"Error launching sub-process UI: {e}")
            messagebox.showerror("Error", f"Could not launch sub-process UI: {e}")
        finally:
            sys.exit(0)
    
    # -----------------------------------------------------------
    # Normal Main Application Startup
    # -----------------------------------------------------------

    # --- REFACTOR: REMOVED ENTIRE `licensing_popup` LOGIC BLOCK ---

    # 2. Proceed with normal application startup (will re-initialize services)
    root = tk.Tk()

    # 3. Instantiate core services
    # Initialize SettingsManager once here (it handles the path resolution)
    settings_mgr = SettingsManager(num_configured_sensors)
    notification_svc = NotificationService(settings_manager=settings_mgr, ui_manager=None)
    temp_logic_svc = TemperatureLogic(ui_callbacks={}, settings_manager=settings_mgr)
    # MODIFIED: Pass all required arguments, flow logic is handled internally by SensorLogic
    sensor_ctrl = SensorLogic(
        num_sensors_from_config=num_configured_sensors,
        ui_callbacks={}, 
        settings_manager=settings_mgr,
        notification_service=notification_svc
    )

    # 4. Instantiate UIManager
    ui = UIManager(
        root,
        settings_mgr,
        sensor_ctrl,
        notification_svc,
        temp_logic_svc,
        num_configured_sensors,
        app_version_string
    )

    # 5. Final link steps
    notification_svc.ui_manager = ui
    if ui.notification_service and hasattr(ui, 'update_notification_status_display'):
        ui.notification_service.ui_manager_status_update_cb = ui.update_notification_status_display
    if ui.temp_logic and hasattr(ui, 'update_temperature_display'):
        ui.temp_logic.ui_callbacks["update_temp_display_cb"] = ui.update_temperature_display
        
    # --- NEW: EULA/SUPPORT POPUP CHECK ON LAUNCH ---
    try:
        system_settings = settings_mgr.get_system_settings()
        eula_agreed = system_settings.get("eula_agreed", False)
        show_on_launch = system_settings.get("show_eula_on_launch", True)
        
        # We show the popup if it's set to show OR if they haven't agreed yet.
        if show_on_launch or not eula_agreed:
            
            # --- THIS IS THE FIX ---
            # Force the main window to draw itself and process events *before*
            # we create the modal popup. This ensures the popup
            # appears on top of the main window, not behind it.
            root.update()
            # --- END FIX ---
            
            print("Main: EULA not agreed or set to show on launch. Opening popup.")
            ui._open_support_popup(is_launch=True)
            
            # After the popup closes, we must re-check if the user
            # disagreed and the app is quitting.
            if not root.winfo_exists():
                print("Main: Root window destroyed after EULA popup. Exiting.")
                sys.exit(0)
        else:
            print("Main: EULA already agreed. Skipping popup.")
            
    except Exception as e:
        print(f"Main: Error during EULA check: {e}")
        messagebox.showerror("Startup Error", f"A critical error occurred during the EULA check: {e}")
        sys.exit(1)
    # --- END EULA CHECK ---

    # 6. Start the schedulers and monitoring
    if notification_svc: notification_svc.start_scheduler()
    if temp_logic_svc: temp_logic_svc.start_monitoring()
    if sensor_ctrl: sensor_ctrl.start_monitoring()
    
    if settings_mgr.get_launch_workflow_on_start():
        ui._open_workflow_popup()
    
    # 7. Start the Tkinter main event loop
    # --- MODIFIED: Wrapped main execution in try...finally for safety ---
    try:
        ui.run()
    except KeyboardInterrupt:
        print("\n[SHUTDOWN] KeyboardInterrupt detected (Ctrl+C).")
    except SystemExit:
        pass # Catches sys.exit()
    except Exception as e:
        print(f"\n[CRITICAL ERROR] Application crashed: {e}")
    finally:
        # This block handles standard exits (Window close, Ctrl+C)
        print("[SHUTDOWN] Performing standard exit cleanup...")
        if 'sensor_ctrl' in locals() and sensor_ctrl:
            sensor_ctrl.cleanup_gpio()
        print("[SHUTDOWN] Cleanup complete.")
    # --- END MODIFIED ---

    print("Main: Application has exited mainloop.")
